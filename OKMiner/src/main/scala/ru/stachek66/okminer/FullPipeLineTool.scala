package ru.stachek66.okminer

import org.slf4j.LoggerFactory
import ru.stachek66.okminer.language.russian.{StopWordsFilter, Lexer, Tokenizer}
import ru.stachek66.okminer.wiki.KeyphrasenessCalculator
import ru.stachek66.okminer.wiki.vocabulary.Vocabulary
import scala.concurrent.duration._
import scala.concurrent.{ExecutionContext, Future, Await}
import scala.util.{Success, Failure, Try}

/**
 * @author alexeyev
 */
object FullPipeLineTool extends App {

  private val log = LoggerFactory.getLogger("test-tool")

  import ExecutionContext.Implicits.global

  val testText = "Исключения и связанная с ними раскрутка стека – одна из самых приятных методик в C++. Обработка исключений интуитивно понятно согласуется с блочной структурой программы. Внешне, обработка исключений представляется очень логичной и естественной.\n\nАккуратное использование стековых объектов позволяет создавать очень эффективный и безопасный код, где, в отличие от систем со сборкой мусора, сохраняется локальность ссылок, что дает возможность уменьшить число обращений к системе за памятью, снизить её фрагментацию, более эффективно использовать кэш памяти.\n\nТем не менее, в C++, исключения традиционно рассматриваются буквально как исключительные ситуации, связанные с восстановлением после ошибок. Трудно сказать, является ли это причиной или следствием того, что реализация обработки исключений компиляторами чрезвычайно дорога. Попробуем разобраться почему.\n\nКак обстоят дела.\n\nСуществует два подхода к реализации обработки исключений:\n\n    Первый можно охарактеризовать словами – “пусть неудачник платит”. Компилятор старается минимизировать издержки в тех случаях, когда исключения не возникают. В идеале, программа не несет никакой дополнительной нагрузки, вся необходимая информация расположена в стороне от кода в некотором удобном для раскрутки виде.\n    Вторая стратегия – “понемногу платят все и всегда\". Иными словами, в процессе работы программа несет определенные издержки на поддержание актуальности информации, необходимой для корректной раскрутки стека. При этом, в случае возникновения исключения, раскрутка стека обходится дешевле.\n\n\nНесколько примеров:\n\n    GCC/SJLJ. SJLJ есть сокращение от setjmp/longjmp. Относится скорее к первому подходу, но благодаря схеме передачи управления, в нем есть еще и фиксированная плата за каждый try. В сущности, данная реализация вобрала в себя всё худшее, что присуще обоим подходам. Вплоть до четвертой версии, это был основной вариант обработки исключений.\n    Как явствует из названия, передача управления осуществляется через вызов longjmp, каждый try порождает вызов setjmp. Соответствующий буфер выделяется в стеке для каждого try блока.\n    В начале каждой функции создается пролог, который регистрирует текущий фрейм в стеке контекстов. Аналогично, создается эпилог, удаляющий текущий контекст с вершины стека контекстов. Рядом с каждой функцией создается вспомогательный код для очистки ресурсов.\n    Если точнее, компилятор каждый возврат из функции, потенциально способный завершиться исключением, заносит в дерево как ключ, значением является указатель на код очистки, который надо в этом месте предпринять для очистки контекста функции. Линкер собирает куски этих деревьев для каждого модуля линковки в единое дерево проекта (очень грубо). Называется это чудо LSDA (language specific data area) и расположено оно в секции \".gcc_except_table\".\n    При возникновении исключения, на основании type_info возбуждаемого исключения отыскивается блок, который может это исключение обработать. Начиная с текущего контекста и вплоть до контекста-обработчика (с помощью навигации по фреймам вызовов), извлекаются и выполняются адреса кода, который (в зависимости от областей видимости локальных переменных) надо исполнить именно в этом месте. После чего передается управление.\n\n    Существует предубеждение, что данный метод является весьма дорогостоящим. Уже в силу того, что на каждый try-блок вызывается setjmp, который недёшев. В самом деле, нужно полностью сохранить состояние процессора, где могут быть десятки регистров. Тогда как на момент возникновения исключения, содержимое большей части этих регистров уже бесполезно. В действительности же, компилятор поступает весьма рационально. Он разворачивает setjmp, причем, сохраняет только полезные регистры (уж эта информация у него есть). Автор сомневается, что издержки на setjmp так уж высоки.\n\n    А вот что действительно бросается в глаза, так это объемный вспомогательный код, особенно в нетривиальных случаях. Компилятор, подобно YACC, расписывает все состояния стекового автомата. И, хотя, оптимизатор по — возможности вычищает избыточность и тривиальный код, того, что остается, более чем достаточно.\n    GCC/DW2. Это как раз пример первого подхода к обработке исключений. DW2 означает DWARF2(теперь уже и 3) – формат хранения вспомогательной, в том числе отладочной информации в исполняемом файле. Ведь отладочная информация нужна и для того, чтобы в любой момент можно было узнать значение любой переменной, в том числе и во фреймах предыдущих (верхних) вызовов. Поэтому компилятор в процессе генерации кода откладывает информацию о том, что он выделяет в стеке, в каких регистрах размещает переменные, когда их сохраняет… В действительности, этот формат не идентичен DWARF, хотя и очень близок к нему. Стандартный вариант для четвертой версии GCC.\n\n    Концептуально, на каждый адрес кода программы хранится информация о том, как попасть в вышестоящий фрейм вызова. На практике ввиду объемности этой информации, она сжимается, фактически, вычисляется с помощью интерпретации байт-кода. Этот байт-код исполняется при возникновении исключения. Расположено всё это в секциях \".eh_frame\" и \".eh_frame_hdr\".\n    Да, помимо всего прочего, DWARF интерпретатор представляет собой отличный backdoor, с помощью которого, подменив байт-код, можно перехватить исключение и отправить его на обработку куда душе угодно.\n    GCC/DW2 использует практически такую же секцию LSDA, что и GCC/SJLJ.\n\n    Как мы видим, издержки, связанные с раскруткой стека (в отсутствие исключений) практически отсутствуют. Однако, стоимость возбуждения исключения велика. Кроме того, нельзя не отметить сильную интеграцию архитектурно-зависимой частью компилятора и достаточно высоко-уровневыми его слоями.\n    MS VC++. Этот компилятор реализует вторую стратегию обработки.\n        Для каждой функции, которая потенциально может выбрасывать исключения, компилятор создает в качестве стековой переменной структуру из указателя на предыдущую подобную структуру, адреса функции-обработчика и вспомогательных данных. Адрес этой структуры заносится в FS:[0], который является вершиной стека этих структур. Регистр FS в Win32 используется как Thread Information Block (TIB) (GS в Win64). Создается также функция-обработчик (со своим набором данных) и эпилог, который восстанавливает FS:[0] в случае успешного завершения.\n        Компилятор создает таблицу структур – по элементу для каждого try-блока в функции. Каждый try-блок имеет индекс начала и конца в этой таблице (вложенный блок имеет вложенный интервал), соответствующий некоторому состоянию, за актуальностью этого индекса сам компилятор и следит. Таким способом компилятор реализует стек try-блоков.\n        На каждый try-блок заводится таблица catch-блоков. На каждый тип исключения заводится таблица type_info всех базовых классов в иерархии данного типа исключения.\n        Для каждой функции создается unwind таблица, каждый элемент которой содержит указатель на функцию, освобождающую некоторый ресурс и номер предыдущего элемента. В таблице может быть несколько цепочек, в зависимости от областей видимости объектов с деструкторами. В момент исключения, по индексу текущего состояния, который упоминался выше, можно найти необходимую цепочку и вызвать все необходимые деструкторы.\n        Для версии x64 вспомогательные стековые структуры по возможности переносились в .pdata, вероятно, в MS считают первую стратегию более перспективной.\n        Инициирование исключения сделано через программное прерывание.\n    Данному методу присущи те же недостатки, что и SJLJ – обширный вспомогательный код и низкая переносимость.\n    Процесс возбуждения исключения и выбора подходящего catch блока везде выглядит примерно одинаково:\n        При возбуждении исключения создается его описатель, в котором содержатся копия объекта, его type_info, указатель на деструктор\n        Поднимаясь по стеку try блоков и очищая за собой все зарегистрированные стековые объекты, (навигация по этому стеку везде разная, но суть одна), просматриваем списки catch блоков и ищем подходящий.\n        Если подходящий catch блок найден, объект-исключение становится локальной переменной, вызываем этот блок. Если catch блок принимает исключение по значению, а не ссылке, создастся его копия.\n        Если перевызова исключения не было, убиваем объект — исключение\n        «Хозяйке на заметку»:\n\n        some_exception exc(\"oioi\");\n        throw exc;\n\n        порождает лишний конструктор копирования / деструктор\n\n        throw *new some_exception(\"oioi\");\n\n        дает утечку памяти\n\n        catch(some_exception exc) ...\n\n        опять лишний вызов конструктора и деструктора\n\n        catch(const some_exception *exc) ...\n\n        исключение пролетит мимо, если не бросить именно указатель\n\n        throw some_exception(\"oioi\");\n        ...\n        catch ([const] some_exception &exc)....\n\n        минимум издержек\n\nПодробности можно посмотреть здесь, здесь и здесь.\n\nА что, если ...\nА, казалось бы, всего и дел то – вызвать в нужном порядке деструкторы, тела которых уже существуют. Как же случилось, что простая, в общем-то, задача имеет такие вязкие, тяжеловесные и притом независимо развивавшиеся решения? Трудно сказать, так исторически сложилось.\nПопробуем набросать решение, стараясь оставить его простым и по возможности архитектурно-независимым.\n\n    Первым делом выбираем стратегию — это будет второй вариант.\n    Передача управления – setjmp/longjmp\n    Создаем класс, все потомки которого обладают способностью само — регистрироваться для возможной раскрутки.\n\n    struct unw_item_t {\n        unw_item_t ();\n        virtual ~unw_item_t ();\n        void unreg();\n        unw_item_t  *prev_;  \n    };\n\n    А также класс, областью видимости которого является try-блок\n\n    struct jmp_buf_splice {    \n        jmp_buf_splice ();\n        ~jmp_buf_splice ();    \n        jmp_buf         buf_;    \n        jmp_buf_splice *prev_;    \n        unw_item_t      objs_;  \n    };\n\n    Для простоты, будем бросать только исключения типа const char * с помощью\n\n        extern int throw_slice (const char *str);\n\n    Несколько макросов для имитации try-блока\n\n    // начало блока\n    #define TRY_BLOCK { \\\n      jmp_buf_splice __sl; \\\n      const char *__exc = (const char *)setjmp (__sl.buf_); \\\n      if (NULL == __exc) {\n    ...\n    // что-то вроде catch(…) т.к. мы бросаем только const char*\n    #define CATCH_BLOCK_FIN  \\\n      } else { \n    ...\n    // конец блока\n    #define FIN_BLOCK  \\\n        } \\\n      }\n    ...\n    // бросаем исключение \n    #define THROW_IN_BLOCK(exc)  \\\n      throw_slice (exc); \n    ...\n    // перебрасываем исключение наверх, __exc определено в TRY_BLOCK\n    #define RETHROW_IN_BLOCK  \\\n      throw_slice (__exc); \n\n    Теперь покажем тела членов класса jmp_buf_splice:\n\n    static jmp_buf_splice *root_slice_ = NULL;  \n    jmp_buf_splice::jmp_buf_splice ()\n    {\n      objs_ = NULL;\n      prev_ = root_slice_;\n      root_slice_ = this;\n    }\n    jmp_buf_splice::~jmp_buf_splice ()\n    {\n      root_slice_ = prev_;\n    }\n\n    Здесь приведен вариант для однопоточной реализации. При наличии нескольких потоков, вместо root_slice_ мы должны будем использовать TLS, аналогично тому, например, как это делает GCC.\n    Пришла пора для членов класса unw_item_t:\n\n    unw_item_t::unw_item_t ()\n    {\n      if (NULL != root_slice_) \n      {\n          prev_ = root_slice_->objs_;\n          root_slice_->objs_ = this;\n      }\n    }\n    unw_item_t::~unw_item_t ()\n    {\n      unreg();\n    }\n    unw_item_t::unreg ()\n    {\n      if (NULL != root_slice_ && \n        (prev_ != reinterpret_cast<unw_item_t *>(~0))) \n      {\n          root_slice_->objs_ = prev_;\n          prev_ = reinterpret_cast<unw_item_t *>(~0);\n      }\n    }\n\n    Теперь рассмотрим процесс возбуждения исключения и раскрутки стека:\n\n    static int pop_slice ()\n    {\n      jmp_buf_splice *sl = root_slice_;\n      assert (NULL != sl);\n      root_slice_ = sl->prev_;\n      return 0;\n    }\n    int throw_slice (const char *str, bool popstate)\n    {\n      if (NULL == str)\n        return -1;\n      jmp_buf_splice *sl = root_slice_;\n      unw_item_t *obj = root_slice_->objs_;\n      while (NULL != obj)\n        {\n          unw_item_t *tmp = obj;\n          obj = obj->prev_;\n          tmp->~unw_item_t ();\n        }\n      if (popstate)\n        pop_slice ();\n      longjmp (sl->buf_, int(str));\t\n      return 0;\n    }\n\n    Сервисный класс – аналог std::auto_ptr:\n    Сервисный класс – массив:\n    Примеры.\n    Тестовый класс\n    Пример 1\n    Пример 2\n    Пример 3\n\n\nОграничения\nТакое решение обладает массой недостатков:\n\n    Нельзя бросать исключения в деструкторе. Деструктор unw_item_t еще не удалил ссылку на данный экземпляр, в результате деструктор будет вызван повторно.\n    Создавать объект наследованного от unw_item_t класса посредством оператора new очень опасно. Даже, если о памяти заботиться самому, такой указатель может попасть в чужой контекст или даже в чужой поток, у объекта, на который он смотрит, могут неожиданно вызвать деструктор, что кончится метаболической катастрофой.\n    Класс, наследованный от unw_item_t, не может быть агрегирован как член другого класса, иначе его деструктор вызовется дважды.\n    Описанный метод невозможно интегрировать с аппаратными исключениями.\n    Ограничения на типы исключений. Выше мы использовали только строковый указатель. Если передавать в качестве исключения примитивные типы, то может быть только один вариант. Если в качестве исключения использовать указатель на объект, то имеем возможность воспользоваться RTTI. Можно предложить что-то вроде\n\n    #define CATCH_BLOCK_TYPED(t)  \\\n      } else if (NULL != dynamic_cast<t>(__exc)) {\n\n    И это даст нам возможность использовать исключения разных типов. Но тогда невозможно бросать исключения примитивных типов.\n    Удалять брошенный объект-исключение должен сам пользователь.\n\n\nИ всё же.\nНесмотря на описанные ограничения, описанный метод обладает неотъемлемыми достоинствами:\n\n    Простота. Несколько десятков строк кода — и все работает.\n    Прозрачность концепции.\n    Легкая переносимость. Никакой зависимости от архитектуры.\n\nСуществует ли возможность устранить недостатки данного метода, сохранив его преимущества? И да, и нет. Пользуясь исключительно средствами C++, это сделать невозможно.\n\nК чему клонит автор.\nВ порядке технического бреда подумаем, как надо модифицировать компилятор, чтобы корректно реализовать вышеописанную схему?\nЧего не хватало в вышеприведенном решении? Знания о том, как был порожден объект.\nНапример, если объект построен на памяти, выделенной из общей кучи и может мигрировать между потоками, его ни в коем случае нельзя регистрировать в потоко-зависимом стеке. Не стоит нигде регистрировать объект, агрегированный в другой объект.\nА с объектом того же типа, но на стековой памяти, это сделать необходимо. Конечно, есть возможность отдать указатель на этот стековый объект в другой поток, но трудно представить, в какой ситуации это могло бы быть полезным.\nИтак:\n\n    Для стековых объектов типа Т компилятор создает на самом деле оберточный класс типа\n\n    template<class T>\n    class __st_wrapper : public unw_item_t  {\n    public:\n        virtual ~__st_wrapper() \n        {\n          unreg();\n          ((T*)data_)->T::~T();\n        };\n    private:\n       char data_[sizeof(T)];\n    };\n\n    а так же вызов нужного конструктора T.\n    Статический член класса jmp_buf_splice::root_slice_ реализуется либо через TLS, либо через соответствующий регистр, если есть\n    Программист по прежнему видит только объект типа Т, расположенный в data_\n    У стековых объектов без виртуальных деструкторов, таковой появляется в обертке\n    Бросать исключения в деструкторах теперь можно т.к. перед вызовом собственно деструктора мы разрегистрировались.\n    Не поддерживаем аппаратные исключения (исключения ядра), поэтому на момент возбуждения исключения компилятор знает какие регистры надо «приземлить» и обязан это сделать\n    Для штатного уничтожения стековых объектов компилятор создает вызовы деструкторов __st_wrapper'ов\n    Механизм выбора подходящего catch блока оставляем как есть. Т.е. вспомогательная табличная информация с описателями этих блоков вне кода нам всё-таки потребуется.\n    Передачу управления будем осуществлять с помощью аналога setjmp. Предлагается реализовать промежуточный (по отношению к двум описанным выше) вариант передачи управления. Setjmp обладает существенным недостатком – размер буфера довольно велик, тогда как реально используется его малая часть.\n    С другой стороны, исполнение байт-кода в духе DWARF представляется весьма расточительным.\n    Поэтому, вместо буфера setjmp будем хранить список регистров, требующих восстановления и сдвиги относительно указателя стека, где лежат актуальные значения. В случае вычисленного значения в регистре хранится непосредственно значение. Для этого в стеке выделяется дополнительная память и отдается сдвиг на нее. Фактически, заводится временная переменная.\n    Перед возбуждением исключения компилятор выгружает все актуальные данные из регистров, в этом случае можно восстановиться без потерь.\n\n    Всё же, стоит отметить, использование блока try — это сознательный акт, нет ничего плохого в том, что это несет за собой определенные издержки. IMHO эти (умеренные) издержки даже полезны т.к. стимулируют ответственное отношение к инструментам языка.\n    Перехват исключений при вызове оператора new и new [ ] оставляем как есть. Т.е. каждую итерацию защищаем внутренним try блоком и уничтожаем всё созданное в предыдущих итерациях, если произошло исключение, которое потом перевозбуждаем. И, конечно, отдаем обратно память, выделенную под объект[ы.]\n    Для реализации массива стековых объектов и делать ничего не надо. Но можно сохранить немного памяти, реализовав специальный стековый объект — вектор, аналогичный тому, что используется при вызове оператора new [].\n\n\n\nКстати.\n\n    Объект может узнать, что он стековый. Для этого его this должен быть в пределах сегмента стека текущего потока.\n    Значит, можно снять объект с крючка? Не представляю, зачем это может понадобиться, но такая возможность существует.\n    Раз можно снять, значит, можно и посадить. Выделить память в стеке через alloca, принудительно вызвать конструктор и подключить к механизму раскрутки стека.\n    Для архитектур с раздельными стеками данных и управления можно реализовать обработку исключений весьма эффективно, используя стек управления вместо списка.\n\n\n\nPS: Отдельное спасибо Александру Артюшину за содержательное обсуждение."

  val splitted = Lexer.split(testText)
  val filtered = StopWordsFilter.filter(splitted.map(_.toLowerCase()))

  val tokens =
    for {
      word <- filtered
      tokenized <- Tokenizer.tokenize(word).headOption
      //todo: think
      if !StopWordsFilter.getList.contains(tokenized)
    } yield {
      if (Vocabulary.normalizedWords.contains(tokenized)) tokenized
      else "dummyword"
    }

  val duples = tokens.zip(tokens.tail)

  val triples = duples.zip(tokens.tail.tail)
  val tetrics = triples.zip(tokens.tail.tail.tail)
  //  val pentics = tetrics.zip(tokens.tail.tail.tail.tail)

  def buildResults(phrases: Iterable[String]): Iterable[(String, Double)] = {
    phrases.map {
      phrase => {
        val kp = Future(KeyphrasenessCalculator.getKeyPhraseness(phrase))
        val res =
          Try {
            Await.result(kp, 4 seconds)
          } match {
            case Failure(e) => {
              log.warn("Takes too long: %s".format(phrase))
              None
            }
            case Success(kps) => {
              if (kps > 0) {
                log.info(kps + "\t" + phrase)
                Some((phrase, kps))
              }
              else None
            }
          }
        res
      }
    }
  }.flatten.toSet

  val dResults: Iterable[(String, Double)] = {
    buildResults(
      duples.map {
        case (first, second) => "%s %s".format(first, second)
      })
  }

  log.info(dResults.toSeq.sortBy(-_._2).take(50).mkString("\n"))
  Thread.sleep(1000)

  val tResults: Iterable[(String, Double)] = {
    buildResults(
      triples.map {
        case ((first, second), third) => "%s %s %s".format(first, second, third)
      })
  }

  log.info(tResults.toSeq.sortBy(-_._2).take(50).mkString("\n"))

  Thread.sleep(1000)

  val ttResults: Iterable[(String, Double)] = {
    buildResults(
      tetrics.map {
        case (((first, second), third), fourth) =>
          "%s %s %s %s".format(first, second, third, fourth)
      })
  }

  log.info(ttResults.toSeq.sortBy(-_._2).take(50).mkString("\n"))
}
