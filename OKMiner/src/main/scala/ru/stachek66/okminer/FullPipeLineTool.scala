package ru.stachek66.okminer

import org.slf4j.LoggerFactory
import ru.stachek66.okminer.language.russian.Tokenizer
import ru.stachek66.okminer.wiki.KeyphrasenessTool
import scala.concurrent.duration._
import scala.concurrent.{ExecutionContext, Future, Await}
import scala.util.{Success, Failure, Try}

/**
 * @author alexeyev
 */
object FullPipeLineTool extends App {

  private val log = LoggerFactory.getLogger("test-tool")

  import ExecutionContext.Implicits.global

  val testText = "" +
    "Мы начинаем серию статей, в которых вы можете рассказать о своём " +
    "сервисе или разработке, которые могут быть полезны для фронтенд-разработчиков." +
    " Есть о чём рассказать? Пишите нам на wst@web-standards.ru — Прим. редактора." +
    "\n\nРассказывать про актуальность векторной графики уже нет никакого смысла — " +
    "количеством различных размеров, разрешений (а теперь еще и плотностей) экранов " +
    "веб-разработчика не удивишь. А вот вопрос подготовки и создания изображений для всего этого разнообразия набирает актуальность с каждым днем. В этой статье я хочу рассказать не о том, как научить дизайнера использовать Illustrator, а о том, как облегчить жизнь разработчика при работе с SVG.\n\nВ последнее время SVG начинают использовать не только в качестве замены растра для иконок и логотипов начинает, но и для создания сложной графики и динамических диаграмм. За это нужно сказать спасибо множеству отличных JavaScript-библиотек, которые позволяют реализовывать все фантазии дизайнеров быстро и легко: Raphaël, Snap.svg, SVG.js, а также тех, что визуализируют разнообразные данные в любом вообразимом виде: D3, Highcharts, GRaphaël.\n\nНо я говорил об облегчении жизни разработчиков: в чем она нелегка, если хороших инструментов так много? Проблемы начинаются, когда перед программистами ставится одна из следующих задач:\n\n    отрисовать графики на сервере, чтобы вставить в email-рассылку;\n    закэшировать результат, потому что каждая отрисовка очередного сложного изображения «подвешивает» браузер на слабой машине;\n    дать пользователю возможность скачать файл в PNG или PDF.\n\nОчевидно, основное преимущество всех этих библиотек становится их самым большим минусом — они работают только в браузере.\n\nРешения этой проблемы уж больно прямолинейные — перетащить браузер на сервер. Тут и решения «headless», например, у highcharts или freckle, или попытки перенести DOM в Node.js для Raphaël.\n\nЭто работает, но инфраструктура для столь небольших потребностей получается монструозной, сложной и часто медленной.\n\nПочему же тогда просто не использовать сторонние серверные библиотеки? Ни один программист в мире не захочет поддерживать две реализации одного и того же на двух разных языках. Это ведет к ошибкам, дополнительным сложностям и высокой итоговой стоимости поддержки и разработки новой функциональности.\n\nМы все это понимаем, поэтому и создали Svable. Это сервис, который позволит вам перенести всю вашу существующую генерацию SVG из браузера на сервер или запускать один и тот же код как на клиенте, так и на сервере.\n\nКак это реализуется? Система состоит из двух частей: самой платформы и адаптеров. Платформа — это API, который принимает на вход специально сформированный JSON с высокоуровневыми командами, вроде: rect, circle, getBBox и т.д. В ответ вы получаете результирующий SVG, PDF или PNG. Мы конвертируем результат, если вам это нужно.\n\nВозьмем для примера вот этот SVG. Как видим, это круг с полупрозрачным stroke и белым квадратом, который рисуется ровно по центру этого круга. И все это на фоне белого прямоугольника с закругленными краями. Допустим, нам позарез нужно отрисовать подобное на сервере. Для этого потребуется сформировать POST-запрос на наш сервис со следующим JSON"

  val tokens = Tokenizer.tokenize(testText)
  val duples = tokens.zip(tokens.tail)
  val triples = duples.zip(tokens.tail.tail)
  val tetrics = triples.zip(tokens.tail.tail.tail)
  val pentics = tetrics.zip(tokens.tail.tail.tail.tail)

  val dResults =
    duples.map {
      case (first, second) => {
        val kp = Future(KeyphrasenessTool.getKeyPhraseness("%s %s".format(first, second)))
        val res =
          Try {
            Await.result(kp, 4 seconds)
          } match {
            case Failure(e) => {
              log.warn("Takes too long")
              0
            }
            case Success(kps) => {
              log.info(kps + "\t" + first + "\t" + second)
              kps
            }
          }
        res
      }
    }
  log.info(dResults.toString())
}
